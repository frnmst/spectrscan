#!/usr/bin/env bash

#
# spectrscan
#
# Copyright (C) 2017 frnmst (Franco Masotti) <franco.masotti@live.com>
#                                            <franco.masotti@student.unife.it>
#
# This file is part of spectrscan.
#
# spectrscan is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# spectrscan is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with spectrscan.  If not, see <http://www.gnu.org/licenses/>.
#

tmp_dir="$(pwd)/.spectrscan-$RANDOM"
src_dir="$(pwd)"

output_file=""

########
########

init()
{
    mkdir "$tmp_dir"
    pushd "$tmp_dir"
} 1>/dev/null 2>/dev/null

scan()
{
    local file_counter="$1"

    local batch_start=1
    local batch_increment=1

    if [ "$file_counter" = "odd" ]; then
        batch_start=1
        batch_increment=2
    elif [ "$file_counter" = "even" ]; then
        batch_start=2
        batch_increment=2
    else
        batch_start=1
        batch_increment=1
    fi

    printf "Scanning...\n" 1>&2-
    # Put source option before resolution to avoid the error:
    # https://bugs.launchpad.net/simple-scan/+bug/983441
    scanimage \
        --source "$source" \
        --batch=spectrscan_out%08d.pnm \
        --batch-start $batch_start \
        --batch-increment $batch_increment \
        --resolution "$resolution" \
        --mode "$mode" \
        --progress \
        --format=pnm
}

exists_output_file()
{
    # Check if output file exists and is a pdf file.
    if [ -f "$src_dir"/"$output_file" ]; then
        if [ "$(file --mime-type "$src_dir"/"$output_file" \
        | awk '{ print $2 }')" = "application/pdf" ]; then
            printf "true"
        else
            # Not a pdf file.
            printf "error"
        fi
    else
        printf "false"
    fi
}

convert_single()
{
    # First convert to pdf with the image enhancements, then apply unpaper.
    # This giuves better results because it avoids missing information in
    # the finakl result.
    local filE="$1"

    pamfix -truncate "$filE" > "$filE".tmp.pnm.bis

    if [ "$imagemagick_options" != "true" ] \
        && [ "$imagemagick_options" != "false" ]; then
        convert $imagemagick_options "$filE".tmp.pnm.bis "$filE".tmp.pnm
    else
        mv "$filE".tmp.pnm.bis "$filE".tmp.pnm
    fi

    if [ "$unpaper_options" = "true" ]; then
        unpaper --overwrite -q "$filE".tmp.pnm "$filE".pnm
    elif [ "$unpaper_options" = "false" ]; then
        mv "$filE".tmp.pnm "$filE".pnm
    else
        unpaper --overwrite -q $unpaper_options "$filE".tmp.pnm "$filE".pnm
    fi

    # OCR stuff goes here.

    convert -compress lzw "$filE".pnm "$filE".pdf

} 1>/dev/null 2>/dev/null

pnm_to_pdf()
{
    printf "PNM to PDF...\n" 1>&2-

    # A hack to avoid GNU Parallel's message
    mkdir -p ~/.parallel && touch ~/.parallel/will-cite
    # n = number of new pages
    # Time complexity: O(n/#threads)
    export -f convert_single
    export unpaper_options
    export imagemagick_options
    parallel --bar convert_single ::: "$(ls spectrscan_*.pnm)"
}

pdf_cat()
{
    printf "Assembling PDF...\n" 1>&2-
    # O(n)
    # Always cat to the output file.
    # Unlike pdfunite, pdftk does not corrupt the pdf.
    pdftk *.pdf cat output "$output_file".tmp

    # O(1)
    if [ "$(exists_output_file)" = "true" ]; then

        cp "$src_dir"/"$output_file" "$src_dir"/."$output_file"

        pdftk "$src_dir"/."$output_file" "$output_file".tmp \
            cat output "$src_dir"/"$output_file"

        rm "$src_dir"/."$output_file"

    elif [ "$(exists_output_file)" = "false" ]; then
        mv "$output_file".tmp "$src_dir"/"$output_file"
    else
        printf "[ERROR]\n" 1>&2-
        exit 1
    fi

    printf "Done.\n" 1>&2-
}

cleanup()
{
    popd
    rm -rf "$tmp_dir"
} 1>/dev/null 2>/dev/null

chain()
{
    init

    if [ "$odd_even" = "true" ]; then
        scan "odd" \
            && printf "Turn the paper(s) and hit return when ready\n" \
            && read \
            && scan "even"
    else
        scan
    fi

    # Feeder out of documents.
    if [ $? -eq 7 ]; then
        printf "No paper inserted\n" 1>&2
        return 1
    fi

    pnm_to_pdf
    pdf_cat
    cleanup
}

get_supported_parameters()
{
    scanimage -A | grep -e '--source' -e '--mode' -e '--resolution'
}

get_supported_resolutions()
{
    local supported_params="${1}"

    echo "${supported_params}" | awk '{print $2}' | tr '|' ' ' | tr -d 'dpi'
}

get_supported_modes()
{
    local supported_params="${1}"

    echo "${supported_params}" | grep mode | awk '{print $2}' | tr '|' ' '
}

get_supported_sources()
{
    local supported_params="${1}"

    echo "${supported_params}" | grep source | awk '{print $2}' | tr '|' ' '
}

check_supported_parameters()
{
    local parameter="$1"
    local value="$2"
    local counter=0
    local parameter_full_name=""
    local p=""

    #TODO.
    parameter_full_name="supported_${parameter}"
    eval "$parameter_full_name='$(get_supported_${parameter})'"
    for p in ${!parameter_full_name}; do
        if [ "$value" = "$p" ]; then
            counter=$(($counter+1))
        fi
    done
    if [ $counter -eq 0 ]; then
        printf "Supported $parameter: ${!parameter_full_name}\n" 1>&2-
        return 1
    fi
}

preliminary_controls()
{
    printf "Probing scanner and its options...\n" 1>&2-

    params="$(get_supported_parameters)"
    [ ${?} -ne 0 ] && return ${?}

    { check_supported_parameters "modes" "$mode" \
        && check_supported_parameters "resolutions" "$resolution" \
        && check_supported_parameters "sources" "$source"; } || return 1

    chain
}

. ./fbopt
